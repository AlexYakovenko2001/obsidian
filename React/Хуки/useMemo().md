[[Хуки]]
### useMemo()

##### Синтаксис:
>const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);

##### Описание:
Возвращает мемоизированное значение.

Передайте «создающую» функцию и массив зависимостей. `useMemo` будет повторно вычислять мемоизированное значение только тогда, когда значение какой-либо из зависимостей изменилось. Эта оптимизация помогает избежать дорогостоящих вычислений при каждом рендере.

Помните, что функция, переданная `useMemo`, запускается во время рендеринга. Не делайте там ничего, что вы обычно не делаете во время рендеринга. Например, побочные эффекты принадлежат `useEffect`, а не `useMemo`.

Если массив не был передан, новое значение будет вычисляться при каждом рендере.

###### Пример использования useMemo: 
![[Pasted image 20220919192405.png]]
Выделенная часть создана специально для того, чтобы приложение зависало на отрисовке при перерендере после изменений в "**a**".

> Важный момент: коллбек внутри useMemo обязательно должен что-то ретурнить, иначе будет падать ошибка

##### Связка useMemo и React.memo
Возможна ситуация, где вынужденно будут создаваться новые объекты (не делаться копии старых, а именно создаваться новые. например, при использовании метода *filter* всегда будет возвращаться новый массив). И если будут создаваться новые объекты, то React.memo будет думать, что произошло что-то важное и отрисовывать компоненту заново, а ничего важного может и не произойти. То есть защита от перерисовок, которая держалась за счёт React.memo работать не будет.

Для таких случаев можно использовать вместо React.memo хук useMemo. Нужно всего лишь закинуть логику изменения стейта в useMemo и добавить зависимость, а переменную, которой присвоили хук useMemo, использовать далее в нужных целях. В таком случае компонента будет защищена от дополнительных перерисовок.