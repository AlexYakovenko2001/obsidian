[[Samurai way]]
###  Store, state, ООП, рефакторинг
**Theory:**
Задача на этот урок - упаковать всё то, что касается данных, которыми оперирует приложение (а именно сам стейт и функции, которые его меняют) в один объект.
**Actions:**
1. Создаём в файле **state.ts** объект *store* (хранилище).
2. Переносим в *store* объект *state*, в котором хранятся данные. Делаем его приватным свойством объекта *store*.                                                                               ![[Pasted image 20221005172526.png]]
3. Переносим в *store* функцию *rerenderEntireTree*, делая её методом объекта *store*. Лучше её сразу переименовать в *callSubscriber*, т.к. она вызывает функцию-подписчика, и сделать приватной, т.к. пользователь не должен использовать её напрямую, она сама вызывается внутри тех функций, где есть необходимость в её вызове.
4. То же самое делаем с функциями *addPost, updateNewPostText, subscribe*. Переписывая внутри них обращение к стейту и к другим функциям с помощью *this*.
5. Меняем экспорт, теперь из файла **state.ts** будет импортироваться только *store*. Раньше из него отдельно экспортировался стейт и каждая функция, теперь экспорт будет только один.
6. Также создаём внутри объекта *store* метод, который позволит нам получать стейт (т.к. само свойство стейт приватное и получать его мы имеем право только с помощью метода, а не прямого обращения к приватному свойству). Назовём данный метод *getStore*. Всё, что он будет делать, так это только возвращать стейт.Теперь для получения стейта нужно будет прописать *store.getState()*
7. Окончательная типизация объекта *store* выглядит так: ![[Pasted image 20221005183751.png]]
8. Далее передаём в пропсах в *App* только объект *store* и дальше рефакторим все остальные пропсы там, где будут возникать ошибки.
9. Но даже если зарефакторить все пропсы и убрать все ошибки, то посты не будут добавляться и даже впечатываться внутри поля ввода ничего не будет. 
Почему так происходит? Тема достаточно сложная и я вряд ли буду в ней разбираться. Суть в том, что с ключевым словом *this* не всё так просто. Для функции, принадлежащей объекту *store* из-за того, что внутри неё используется слово *this*, имеет значение где её вызывают. Мы прокидываем функции по добавлению поста и впечатыванию каждого символа в поле ввода как коллбеки внутрь компоненты *MyPosts*, и уже там они вызываются. Вызов выглядит так: *props.addPost* или *props.updateNewPostText* и т.к. пропсы - это объект, то функция думает, что слово *this* относится к объекту *props*, а не к объекту *store*. 
Как это решается? Достаточно в первом месте, где функция прокидывается как коллбек, связать её с объектом, к которому должно относиться ключевое слово *this*. В нашем случае это происходит в компоненте *Арр*. Выглядит это вот так: ![[Pasted image 20221005191417.png]]

